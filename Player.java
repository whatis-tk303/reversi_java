/* @file	Player.java
 * @date	2018-02-18
 * @author	TK303
 *
 * @description
 *
 *	class Player : ゲームのプレイヤーの抽象クラス
 *	＜責務＞
 *	  - プレイヤーができる操作を担う
 *			(constructor)	プレイヤーの名前と先手・後手を指定してプレイヤーを生成する
 *			think			駒を置く場所を考える
 *			getPieceType	駒の種別を取得する
 *
 *	class HumanPlayer : 手動操作をするプレイヤー
 *	＜責務＞
 *	  - 手動操作プレイヤー（人間）ができる操作を担う
 *			(constructor)	
 *			doThink			駒を置く場所を考える（手動で場所を選択する操作を含む）
 *			setPiece		？？？（外部から駒を置く場所を指示する）
 *
 *	class AutoPlayer : 自動操作をするプレイヤー
 *	＜責務＞
 *	  - 自動操作プレイヤー（コンピューター）ができる操作を担う
 *			(constructor)	
 *			doThink			駒を置く場所を考える（盤面状況から自動で判断する）
 */


import java.util.*;
import java.awt.*;


/*********************************************************************************
 * @brief	リバーシのプレイヤー（抽象クラス）
 */
abstract class Player
{
	  public enum Type {
		 HUMAN,
		 COMPUTER
	  }

	  protected ReversiBoard m_board;			/* 盤面 */
	  protected String m_name;					/* プレイヤーの名前 */
	  protected Type m_player_type;				/* プレイヤー { HUMAN | COMPUTER} */
	  protected ReversiPiece.Type m_piece_type;	/* 自分の駒の色 { BLACK | WHITE } ※ 黒が先手 */

	  /********************************************************************************
	   * @brief		constructor
	   */
	  public Player(ReversiBoard board, String name, Player.Type player_type, ReversiPiece.Type piece_type)
	  {
		 m_board = board;
		 m_name = name;
		 m_player_type = player_type;
		 m_piece_type = piece_type;
	  }

	  /********************************************************************************
	   * @brief		駒を置く場所を考える
	   * @return	駒を置く場所、置けない場合は null
	   */
	  public Point think(HashMap<Point, Vector<Point>> candidate_pos_map)
	  {
		 if (candidate_pos_map.size() != 0)
		 {
			return doThink(candidate_pos_map);
		 }
		 else
		 {
			return null;
		 }
	  }

	  /* @brief		駒の種別を取得する */
	  public ReversiPiece.Type getPieceType()
	  {
		 return m_piece_type;
	  }

	  /* @brief	駒の種別を取得する */
	  @Override /*  */
	  public String toString()
	  {
		 return m_name;
	  }

	  /* @brief		駒を置く場所を考える
	   * @return	駒を置く場所
	   * @note		駒が置けない場合には、このメソッドが呼ばれることはない
	   */
	  abstract protected Point doThink(HashMap<Point, Vector<Point>> candidate_pos_map);

	  /********************************************************************************
	   * @brief		自動プレイかどうか問い合わせる
	   * @return	true: 自動プレイできます
	   */
	  abstract public boolean isAutoPlay();
}


/*********************************************************************************
 * @brief	リバーシのプレイヤー（人間）
 * @note	人間が考えて駒を置く場所を教える
 */
class HumanPlayer extends Player
{
	  private Point m_pos;
	  private HashMap<Point, Vector<Point>> m_candidate_pos_map;
	  private Thread m_thread_think;

	  /* @brief	constructor */
	  public HumanPlayer(ReversiBoard board, String name, ReversiPiece.Type piece_type)
	  {
		 super(board, name, Player.Type.HUMAN, piece_type);
	  }

	  /********************************************************************************
	   * @brief	駒を置く場所を考える
	   * @note		駒が置けない場合には、このメソッドが呼ばれることはない
	   */
	  @Override
	  protected Point doThink(HashMap<Point, Vector<Point>> candidate_pos_map)
	  {
		 m_pos = null;
		 m_candidate_pos_map = candidate_pos_map;

		 m_thread_think = new Thread(new Runnable(){
				  public void run()
				  {
					 while(true)
					 {
						try
						{
						   /* 駒が置かれたらループを抜ける */
						   if (getPos() != null)
						   {
							  break;
						   }

						   Thread.sleep(100);  /* システムの負荷を上げないように・・・ */
						   /* まだ駒が置かれてないうちに wait()を抜けてきた
							*    → 盤面を再描画する（移動するハンドを描画するため） */
						   m_board.repaint();
						}
						catch(Exception e)
						{
						   System.out.println(e);
						}
					 }
				  }
			});


		 /* 人間が駒を置くまで待つ */
		 try
		 {
			m_thread_think.start();
			m_thread_think.join();
		 }
		 catch(Exception e)
		 {
			System.out.println(e);
		 }

		 return m_pos;
	  }

	  /********************************************************************************
	   * @brief		自動プレイかどうか問い合わせる
	   * @return	true: 自動プレイできます
	   */
	  public boolean isAutoPlay()
	  {
		 return false;
	  }

	  /********************************************************************************
	   * @brief		指定された場所に駒を置けるかを問い合わせる
	   * @param [in]	x, y - 駒を置きたい場所
	   * @return	true: 駒を置ける、false: 置けない
	   */
	  public boolean isAvailablePos(Point pos_place)
	  {
		 ReversiPiece piece = m_board.getPiece(pos_place.x, pos_place.y);
		 /* 盤面上で駒が置かれてない場所なら、駒を置けるかどうかを確認する */
		 if (piece == null)
		 {
			for (Point pos : m_candidate_pos_map.keySet())
			{
			   System.out.printf("can place (%d,%d) == (%d,%d) ?\n", pos_place.x, pos_place.y, pos.x, pos.y);

			   if (pos.equals(pos_place))
			   {
				  /* ここには駒を置ける */
				  return true;
			   }
			}
		 }

		 /* 駒を置けなかった */
		 return false;
	  }

	  /********************************************************************************
	   * @brief		指定された場所に駒を置く
	   * @param [in]	x, y - 駒を置きたい場所
	   */
	  synchronized public void setPos(Point pos)
	  {
		 m_pos = pos;
	  }


	  /********************************************************************************
	   * @brief		指定された場所に駒を置く
	   * @param [in]	x, y - 駒を置きたい場所
	   */
	  synchronized private Point getPos()
	  {
		 return m_pos;
	  }
}


/*********************************************************************************
 * @brief	リバーシのプレイヤー（コンピューター）
 * @note	自分で考えて駒を置く
 */
class AutoPlayer extends Player
{
	  /********************************************************************************
	  * @brief		constructor
	  */
	  public AutoPlayer(ReversiBoard board, String name, ReversiPiece.Type piece_type)
	  {
		 super(board, name, Player.Type.COMPUTER, piece_type);
	  }

	  /********************************************************************************
	   * @brief	駒を置く場所を考える
	   * @note		駒が置けない場合には、このメソッドが呼ばれることはない
	   */
	  @Override
	  protected Point doThink(HashMap<Point, Vector<Point>> candidate_pos_map)
	  {
		 Point pos = null;
		 /* TODO: 20180218  コンピューターは駒を置ける場所を自力で探す
		  * （今はとりあえずランダムで置けるところを選択して置く） */
		 int num = candidate_pos_map.size();
		 int idx = (new Random()).nextInt(num);
		 pos = (Point)(candidate_pos_map.keySet().toArray()[idx]);

		 return pos;
	  }

	  /********************************************************************************
	   * @brief		自動プレイかどうか問い合わせる
	   * @return	true: 自動プレイできます
	   */
	  public boolean isAutoPlay()
	  {
		 return true;
	  }
}
